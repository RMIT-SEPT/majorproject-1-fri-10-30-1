/**
 * @fileoverview A rule to suggest using template literals instead of string concatenation.
 * @author Toru Nagashima
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a given node is a concatenation.
 * @param {ASTNode} node A node to check.
 * @returns {boolean} `true` if the node is a concatenation.
 */
function isConcatenation(node) {
    return node.type === "BinaryExpression" && node.operator === "+";
}

/**
 * Gets the top binary expression node for concatenation in parents of a given node.
 * @param {ASTNode} node A node to get.
 * @returns {ASTNode} the top binary expression node in parents of a given node.
 */
function getTopConcatBinaryExpression(node) {
    let currentNode = node;

    while (isConcatenation(currentNode.parent)) {
        currentNode = currentNode.parent;
    }
    return currentNode;
}

/**
 * Determines whether a given node is a octal escape sequence
 * @param {ASTNode} node A node to check
 * @returns {boolean} `true` if the node is an octal escape sequence
 */
function isOctalEscapeSequence(node) {

    // No need to check TemplateLiterals â€“ would throw error with octal escape
    const isStringLiteral = node.type === "Literal" && typeof node.value === "string";

    if (!isStringLiteral) {
        return false;
    }

    return astUtils.hasOctalEscapeSequence(node.raw);
}

/**
 * Checks whether or not a node contains a octal escape sequence
 * @param {ASTNode} node A node to check
 * @returns {boolean} `true` if the node contains an octal escape sequence
 */
function hasOctalEscapeSequence(node) {
    if (isConcatenation(node)) {
        return hasOctalEscapeSequence(node.left) || hasOctalEscapeSequence(node.right);
    }

    return isOctalEscapeSequence(node);
}

/**
 * Checks whether or not a given binary expression has string literals.
 * @param {ASTNode} node A node to check.
 * @returns {boolean} `true` if the node has string literals.
 */
function hasStringLiteral(node) {
    if (isConcatenation(node)) {

        // `left` is deeper than `right` normally.
        return hasStringLiteral(node.right) || hasStringLiteral(node.left);
    }
    return astUtils.isStringLiteral(node);
}

/**
 * Checks whether or not a given binary expression has non string literals.
 * @param {ASTNode} node A node to check.
 * @returns {boolean} `true` if the node has non string literals.
 */
function hasNonStringLiteral(node) {
    if (isConcatenation(node)) {

        // `left` is deeper than `right` normally.
        return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);
    }
    return !astUtils.isStringLiteral(node);
}

/**
 * D